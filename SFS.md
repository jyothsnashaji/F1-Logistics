[cite_start]This document details the architecture and API specifications for the **F1 Logistics Multi-Objective Optimization System**, which is based on the **Adaptive $\epsilon$-Constraint Method** and **Modified TOPSIS with the D-CRITIC Method**[cite: 1678, 2370].

---

## 1. System Architecture Overview
[cite_start]The system is designed as a three-phase pipeline, mirroring the methodology of the base paper and the F1 Logistics report[cite: 1696, 1697, 1698, 2401, 2404].

| Phase | Core Task | Key Algorithm | Output |
| :--- | :--- | :--- | :--- |
| **Phase 1** | **Data Preparation** | Data Loading & Structuring | Structured Data Model |
| **Phase 2** | **Optimization** | **Adaptive $\epsilon$-Constraint Method** | [cite_start]**Pareto Frontier** (Decision Matrix) of non-dominated schedules [cite: 2401] |
| **Phase 3** | **Decision Making** | **D-CRITIC** and **Modified TOPSIS** | [cite_start]Ranked list of schedules [cite: 2404] |

[cite_start]The system uses four objective functions ($Z_c, c=1..4$) for the F1 Logistics problem[cite: 2399, 2400]:
* [cite_start]$Z_1$: **Minimize Logistical Cost** [cite: 2383]
* [cite_start]$Z_2$: **Minimize Environmental Impact ($CO_2e$ Emissions)** [cite: 2385]
* [cite_start]$Z_3$: **Maximize Commercial Revenue** [cite: 2386]
* [cite_start]$Z_4$: **Minimize Team Fatigue** (via Minimizing Travel Time) [cite: 2419]

---

## 2. Phase 1: Data Preprocessing and Loading

### 2.1. Required Input Values (Parameters)

[cite_start]To form the Multi-Objective Integer Linear Programming (MOILP) model, the following values are needed, derived from the F1 Logistics problem formulation[cite: 2409, 2410, 2411, 2412, 2413, 2414, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423]:

| Parameter | Description | Source Field |
| :--- | :--- | :--- |
| $V$ | Set of all available circuits (nodes) | `CIRCUITS` |
| $A$ | Set of all possible arcs (links) between circuits | `TRANSPORT_LINKS` |
| $M$ | Set of transport modes (Air, Road, Sea, etc.) | `TRANSPORT_LINKS` |
| $K$ | Total number of required races | `SEASON_CONFIG` |
| $S, E$ | Designated starting and ending circuits | `SEASON_CONFIG` |
| $C_{ij}^m$ | Cost of travel from $i$ to $j$ by mode $m$ | `TRANSPORT_LINKS` |
| $E_{ij}^m$ | $CO_2e$ Emissions from $i$ to $j$ by mode $m$ | `TRANSPORT_LINKS` |
| $R_i$ | Hosting fee revenue for circuit $i$ | `CIRCUITS` |
| $D_{ij}^m$ | Travel time (days) from $i$ to $j$ by mode $m$ | `TRANSPORT_LINKS` |
| $T^{max}$ | Maximum total days available for the season | `SEASON_CONFIG` |
| $T^{min}_{rest}$ | Minimum rest/prep days between races | `SEASON_CONFIG` |
| $L^{min}$ | Minimum required lead time for Sea Freight | `SEASON_CONFIG` |

### 2.2. Data Model (Tables and Columns)

The raw data is structured into three primary relational tables:

| Table Name | Column | Data Type | Description |
| :--- | :--- | :--- | :--- |
| **`CIRCUITS`** | `circuit_id` (PK) | String | Unique circuit identifier. |
| | `name` | String | Circuit name (e.g., 'Monaco'). |
| | `hosting_fee_revenue_Ri` | Float | Commercial Revenue generated by the race ($R_i$). |
| **`TRANSPORT_LINKS`** | `link_id` (PK) | String | Unique identifier for link/mode combination. |
| | `origin_circuit_i` (FK) | String | Starting circuit. |
| | `dest_circuit_j` (FK) | String | Destination circuit. |
| | `mode_m` | String | Transport mode (e.g., 'Air', 'Road', 'Sea'). |
| | `cost_Cijm` | Float | Logistical Cost ($C_{ij}^m$). |
| | `emissions_Eijm` | Float | $CO_2e$ Emissions ($E_{ij}^m$). |
| | `travel_time_Dijm` | Integer | Travel Time in days ($D_{ij}^m$). |
| **`SEASON_CONFIG`** | `parameter` (PK) | String | Parameter name (e.g., 'K', 'S', 'Tmax'). |
| | `value` | Varies | The associated parameter value. |

### 2.3. Data Loader Class API


The following APIs are implemented in `data_loader.py`:

| API Method | Input | Output | Description |
| :--- | :--- | :--- | :--- |
| `__init__` | None | None | Loads available circuits and transport links from CSV files. |
| `load_circuits()` | None | List[str] | Returns the list of available circuit IDs. |
| `load_transport_links()` | None | List[dict] | Returns the transport links as a list of dictionaries. |
| `get_season_start_end()` | None | Tuple[str, str] | Returns the season start and end circuit IDs. |
| `get_minimum_rest_days()` | None | int | Returns the minimum rest days between races. |
| `get_lead_time_min()` | None | int | Returns the minimum required lead time for sea freight. |
| `get_time_taken_per_link()` | None | int | Returns the time taken per transport link (days). |

---

## 3. Phase 2: Adaptive $\epsilon$-Constraint Method

[cite_start]This phase solves the MOILP to generate the Pareto Frontier, which is the Decision Matrix for the subsequent TOPSIS step[cite: 2400, 2401].

### 3.1. `MultiObjectiveSolver` Class API

| API Method | Input | Output | Description |
| :--- | :--- | :--- | :--- |
| **`generate_pareto_frontier`** | `data` (dict), `primary_obj_idx` (int), `num_grid_points` (int) | `DataFrame` (Decision Matrix) | Executes the Adaptive $\epsilon$-Constraint method to find all non-dominated solutions. |

* **Input Notes**:
    * `data`: The output from `LogisticsDataLoader.load_all_data()`.
    * `primary_obj_idx`: The index of the objective to optimize (e.g., 3 for Maximize Revenue).
    * [cite_start]`num_grid_points`: The resolution of the $\epsilon$-grid for the constraints[cite: 2403].

* [cite_start]**Output (Decision Matrix)**: A matrix where each row is a unique non-dominated schedule (alternative route) and columns are the four objective values, along with the corresponding binary decision variables $x_{ij}^m$[cite: 2324].

### 3.2. Internal Implementation: Adaptive $\epsilon$-Constraint

1.  [cite_start]**Objective Formulation**: The primary problem is to optimize one objective ($Z_p$) subject to constraints on the others[cite: 2402]. [cite_start]The F1 MOILP (a variant of the Multimodal Routing Problem [cite: 1803]) is converted into a series of single-objective ILP problems.

    $$\text{Minimize } Z_p(\mathbf{x})$$

    $$\text{Subject to: } Z_c(\mathbf{x}) \le \epsilon_c \quad \forall c \in \{1, 2, 4\}, c \ne p \quad (\text{for minimization objectives})$$
    $$\text{Subject to: } Z_c(\mathbf{x}) \ge \epsilon_c \quad \forall c \in \{3\}, c \ne p \quad (\text{for maximization objectives})$$
    $$\text{Plus the F1 specific constraints (race count, flow equilibrium, etc.)}$$

2.  [cite_start]**Solver and Constraints**: The internal engine uses a specialized **MILP solver** library (e.g., **Gurobi** or CPLEX) to handle the binary variables ($x_{ij}^m, y_i$) and constraints[cite: 1816].

3.  **Adaptive Grid Generation**:
    * [cite_start]Calculate the **Utopia/Nadir points** (best/worst values for each objective) by solving four single-objective models[cite: 2392, 2393].
    * [cite_start]Generate a grid of $\epsilon_c$ values for the constraint objectives based on their range (Nadir - Utopia) and the `num_grid_points` input, as described in the Adaptive $\epsilon$-constraint method[cite: 2403]. [cite_start]This guarantees that all non-dominated solutions are found[cite: 1796].

---

## 4. Phase 3 & 4: D-CRITIC and Modified TOPSIS

[cite_start]These methods are combined into a single decision-making class to rank the set of Pareto solutions generated in Phase 2[cite: 1697, 1698].

### 4.1. `DecisionMaker` Class API

| API Method | Input | Output | Description |
| :--- | :--- | :--- | :--- |
| **`calculate_weights_d_critic`** | `decision_matrix` (DataFrame) | `Series/List` of weights $W_c$ | [cite_start]Computes objective weights based on the D-CRITIC method[cite: 2324]. |
| **`rank_schedules_topsis`** | `decision_matrix` (DataFrame), `weights` (Series/List) | `DataFrame` (Final Ranking Table) | [cite_start]Ranks the schedules using the Modified TOPSIS method[cite: 2404]. |

### 4.2. Internal Implementation: D-CRITIC (Task 3)

[cite_start]The Distance Correlation-based Criteria Importance Through Inter-criteria Correlation (D-CRITIC) method calculates weights based on two factors[cite: 1798]:
1.  **Contrast Intensity** (Standard Deviation, $SD_c$): Measures how much the values of an objective differ across alternatives.
2.  **Conflict** (Inter-criteria Correlation): Measures the correlation between the objective values. A low correlation means a high conflict, giving the objective a higher weight. [cite_start]D-CRITIC uses **Distance Correlation**, which captures both linear and non-linear relationships, unlike the classical CRITIC method[cite: 1798].

* **Steps**:
    1.  **Calculate Standard Deviation** ($SD_c$) for each objective $c$.
    2.  **Calculate Distance Correlation Matrix** ($\mathbf{r}$) between all pairs of objectives.
    3.  **Calculate Conflict ($T_c$)**: $T_c = \sum_{p=1}^{C} (1 - r_{cp})$ (where $C=4$).
    4.  **Calculate Information Content ($I_c$)**: $I_c = SD_c \cdot T_c$.
    5.  **Normalize to find Final Weight ($W_c$)**: $W_c = I_c / \sum_{p=1}^{C} I_p$.

### 4.3. Internal Implementation: Modified TOPSIS (Task 4)

[cite_start]The Technique for Order of Preference by Similarity to Ideal Solution (TOPSIS) ranks alternatives by determining the solution closest to the **Positive Ideal Solution (PIS)** and farthest from the **Negative Ideal Solution (NIS)**[cite: 2405].

* **Steps**:
    1.  [cite_start]**Normalization**: Normalize the decision matrix ($\mathbf{X}$) to create a scale-free matrix ($\mathbf{N}$) (e.g., using vector normalization)[cite: 2341].
    2.  [cite_start]**Weighted Normalization**: Apply the D-CRITIC weights ($W_c$) to $\mathbf{N}$ to get the weighted normalized matrix ($\mathbf{V}$)[cite: 2346]. $V_{ij} = W_j \cdot N_{ij}$.
    3.  [cite_start]**Determine PIS ($V^+$) and NIS ($V^-$)**: Identify the best and worst values for each objective from $\mathbf{V}$[cite: 2353].
        * For Minimization objectives ($Z_1, Z_2, Z_4$): $V_c^+ = \min(V_{ic})$, $V_c^- = \max(V_{ic})$.
        * For Maximization objective ($Z_3$): $V_c^+ = \max(V_{ic})$, $V_c^- = \min(V_{ic})$.
    4.  [cite_start]**Calculate Separation Distances**: Compute the Euclidean distance of each schedule ($i$) from the PIS ($d_i^+$) and NIS ($d_i^-$)[cite: 2353].
    5.  [cite_start]**Calculate Closeness Score ($C_i$)**: $C_i$ represents the overall performance score[cite: 1406].

    $$C_{i} = \frac{d_{i}^{-}}{d_{i}^{-} + d_{i}^{+}} \in [0, 1]$$
    6.  [cite_start]**Rank Alternatives**: The final ranking is determined by the Closeness Score ($C_i$), where a higher score indicates a better-balanced schedule (closer to the ideal solution)[cite: 2364].

[cite_start]The final output is a table showing each schedule's objective values ($Z_1$ to $Z_4$), its $C_i$ score, and its final rank, with the rank 1 schedule being the best compromise[cite: 2365].